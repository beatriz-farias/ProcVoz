<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oráculo das Sombras</title>
    <meta name="description" content="Processamento de Voz e Reconhecimento de Fala em Narrativas Interativas">

    <link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
        :root {
            --dark-bg: #1a1a1a;
            --darker-bg: #111;
            --container-bg: #2b2b2b;
            --border-color: #ff4500; /* Laranja avermelhado vibrante */
            --text-color: #e0e0e0;
            --accent-color: #aaffaa; /* Verde claro para respostas */
            --error-color: #ff6347; /* Tomate para erros */
            --shadow-color: rgba(255, 69, 0, 0.5);
            --transition-speed: 0.3s;
        }

        body {
            font-family: 'Poppins', sans-serif; /* Fonte geral mais limpa */
            background-color: var(--dark-bg);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-image: url('https://www.transparenttextures.com/patterns/dark-fish-skin.png'); /* Textura sutil de horror */
            text-align: center;
        }

        h1 {
            font-family: 'Creepster', cursive; /* Fonte especial para o título */
            font-size: 3.5em; /* Tamanho maior */
            color: var(--border-color);
            text-shadow: 3px 3px 6px var(--shadow-color); /* Sombra mais intensa */
            margin-bottom: 10px;
            letter-spacing: 2px; /* Espaçamento entre letras */
        }

        h2 {
            font-size: 1.2em;
            color: var(--text-color);
            margin-top: 0;
            margin-bottom: 40px;
            opacity: 0.8;
        }

        .game-container {
            background-color: var(--container-bg);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 40px;
            box-shadow: 0 0 25px var(--shadow-color); /* Sombra mais pronunciada */
            width: 90%;
            max-width: 700px; /* Um pouco maior */
            text-align: center;
            animation: fadeIn 1.5s ease-out; /* Animação de entrada */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #story-text {
            min-height: 100px; /* Maior altura para mais texto */
            background-color: var(--darker-bg);
            border: 1px solid var(--border-color);
            padding: 20px;
            margin-bottom: 25px;
            border-radius: 8px;
            text-align: left;
            white-space: pre-wrap;
            font-size: 1.1em;
            line-height: 1.6;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.5); /* Sombra interna sutil */
        }

        .button-group {
            display: flex;
            justify-content: center;
            gap: 15px; /* Espaço entre os botões */
            margin-bottom: 20px;
        }

        button {
            background-color: var(--border-color);
            color: white;
            padding: 14px 30px; /* Botões maiores */
            border: none;
            border-radius: 8px; /* Cantos mais suaves */
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600; /* Mais negrito */
            transition: background-color var(--transition-speed) ease, transform 0.1s ease, box-shadow var(--transition-speed) ease;
            text-transform: uppercase; /* Texto em maiúsculas */
            letter-spacing: 0.5px;
        }

        button:hover {
            background-color: #e63900; /* Laranja mais escuro no hover */
            transform: translateY(-3px); /* Pequeno efeito de elevação */
            box-shadow: 0 5px 15px rgba(255, 69, 0, 0.4); /* Sombra no hover */
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(255, 69, 0, 0.3);
        }

        button:disabled {
            background-color: #555;
            color: #bbb;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #recording-status {
            margin-top: 15px;
            font-size: 1em;
            font-style: italic;
            color: #bbb;
        }

        #ai-response {
            margin-top: 25px;
            font-size: 1.6em; /* Resposta maior */
            font-weight: 600; /* Mais negrito */
            color: var(--accent-color);
            min-height: 40px; /* Garante espaço */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            animation: pulseText 1.5s infinite alternate; /* Efeito de pulso para a resposta */
        }

        @keyframes pulseText {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }

        .error-message {
            margin-top: 15px;
            font-size: 0.95em;
            color: var(--error-color);
            font-weight: 600;
        }

        .disclaimer {
            font-size: 0.8em;
            color: #888;
            margin-top: 30px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Oráculo das Sombras</h1>
    <h2>Processamento de Voz e Reconhecimento de Fala em Narrativas Interativas</h2>

    <div class="game-container">
        <p id="story-text">Você se encontra em uma mansão antiga e escura. Há um sussurro no ar. O que você quer perguntar à entidade?</p>

        <p id="recording-status">Pronto para gravar.</p>
        
        <div class="button-group">
            <button id="start-record-button">Começar a Gravar</button>
            <button id="stop-record-button" disabled>Parar Gravação e Perguntar</button>
        </div>
        
        <p id="ai-response"></p>
        <p class="error-message" id="error-message"></p>
        <p class="disclaimer">
            Este jogo utiliza processamento de voz offline e IA para as interações.
        </p>
    </div>

    <script>
        // --- Constantes e Seleção de Elementos ---
        const startRecordButton = document.getElementById('start-record-button');
        const stopRecordButton = document.getElementById('stop-record-button');
        const recordingStatus = document.getElementById('recording-status');
        const aiResponse = document.getElementById('ai-response');
        const storyText = document.getElementById('story-text');
        const errorMessage = document.getElementById('error-message');

        const API_URL = 'http://127.0.0.1:8000/ask_ai_audio'; // Seu endpoint FastAPI
        
        // Variáveis de Gravação e Charada
        let mediaRecorder;
        let audioChunks = [];
        let audioBlob;
        const CURRENT_RIDDLE = "Sou leve como uma pena, mas nem o homem mais forte consegue me segurar por muito tempo. O que sou eu?";
        const CURRENT_RIDDLE_ANSWER = "Respiração";
        let currentStorySnippet = `Você se encontra em uma mansão antiga e escura. Há um sussurro no ar. A charada que você precisa resolver é: "${CURRENT_RIDDLE}". O que você quer perguntar à entidade?`;

        // --- Inicialização da História ---
        document.addEventListener('DOMContentLoaded', () => {
            storyText.textContent = currentStorySnippet;
        });

        // --- Event Listeners para Gravação ---
        startRecordButton.addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = []; // Limpa chunks anteriores

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    sendAudioToAPI(audioBlob); // Chama a função para enviar ao backend
                };

                mediaRecorder.start();
                updateButtonStates(true, false); // Desabilita start, habilita stop
                recordingStatus.textContent = 'Gravando... Fale sua pergunta.';
                aiResponse.textContent = '';
                errorMessage.textContent = '';

            } catch (err) {
                console.error('Erro ao acessar o microfone:', err);
                errorMessage.textContent = 'Não foi possível acessar o microfone. Por favor, verifique as permissões.';
                recordingStatus.textContent = 'Erro ao gravar.';
                updateButtonStates(false, false); // Habilita start, desabilita stop
            }
        });

        stopRecordButton.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                updateButtonStates(true, false); // Desabilita ambos enquanto processa
                recordingStatus.textContent = 'Processando sua pergunta...';
            }
        });

        // --- Função para Gerenciar Estados dos Botões ---
        function updateButtonStates(isRecordingActive, isProcessingActive) {
            startRecordButton.disabled = isRecordingActive || isProcessingActive;
            stopRecordButton.disabled = !isRecordingActive || isProcessingActive;
        }

        // --- Função Chave: sendAudioToAPI (Envio, Recebimento e Exibição) ---
        async function sendAudioToAPI(blob) {
            aiResponse.textContent = "A entidade está ouvindo e ponderando sua pergunta...";
            errorMessage.textContent = ""; 

            const formData = new FormData();
            formData.append('audio_file', blob, 'recording.webm');
            formData.append('riddle', CURRENT_RIDDLE);
            formData.append('riddle_answer', CURRENT_RIDDLE_ANSWER);

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    body: formData
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro na API: ${response.status} ${response.statusText} - ${errorData.detail || 'Detalhe desconhecido'}`);
                }

                const data = await response.json();
                
                aiResponse.textContent = `A Entidade responde: ${data.answer}`;

                if (data.audio) {
                    const audioBase64 = data.audio;
                    const audio = new Audio(`data:audio/mp3;base64,${audioBase64}`);
                    audio.play().catch(e => console.error("Erro ao tentar tocar áudio:", e));
                }

                // --- Lógica para Atualizar a História ---
                let newStorySnippet = '';
                if (data.answer === "Sim") {
                    newStorySnippet = `A entidade confirmou! A resposta foi 'Sim'. Isso o ajuda na charada: "${CURRENT_RIDDLE}"?`;
                } else if (data.answer === "Não") {
                    newStorySnippet = `A entidade negou. A resposta foi 'Não'. Isso o ajuda na charada: "${CURRENT_RIDDLE}"?`;
                } else if (data.answer === "Irrelevante") {
                    newStorySnippet = `A entidade não considera sua pergunta relevante para a charada. Tente reformular: "${CURRENT_RIDDLE}"?`;
                } else if (data.answer === "Não é uma pergunta sim/não") {
                    newStorySnippet = `A entidade insiste que sua pergunta não pode ser respondida com Sim ou Não. Por favor, faça uma pergunta sim/não para a charada: "${CURRENT_RIDDLE}"`;
                } else if (data.answer.includes("Não consegui entender sua pergunta no áudio")) {
                    newStorySnippet = `A entidade não conseguiu entender o áudio. Por favor, fale mais claramente ou tente novamente.`;
                } else if (data.answer.includes("Desculpe, a entidade está ocupada no momento")) {
                    newStorySnippet = `A entidade está tendo dificuldades para se comunicar. Tente novamente em alguns instantes.`;
                }
                storyText.textContent = newStorySnippet + "\n\nO que mais você quer perguntar à entidade?";

            } catch (error) {
                console.error("Erro ao chamar a API:", error);
                errorMessage.textContent = `Erro ao contatar a Entidade: ${error.message}.`;
                aiResponse.textContent = ""; 
            } finally {
                updateButtonStates(false, false); // Habilita start, desabilita stop (quando processamento termina)
                recordingStatus.textContent = 'Pronto para gravar.';
            }
        }
    </script>
</body>
</html>